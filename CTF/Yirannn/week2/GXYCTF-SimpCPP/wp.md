进入main拉到最下面看到关键判断，需要两个位运算表达式相等，并且v3这个bool的值为1

先看v3

若要求v3为1，则有 ：v30 ^ v20[3] == 0x3E3A

即

​	v20[3] = 0x32310600

​	v30 = v26 | v25 | v28 | v29 = 0x3E3A4717373E7F1F

​	v33 = v28 & v20[0] | v32 & (v25 | v31 & ~v20[0] | ~(v31 | v20[0])) = 0x8020717153E3013

水平不够，一个一个看过去吧，不过这么复杂的约束，应该大概率是z3求解。不管怎么样，先通读一遍吧。先从v20[0]开始：

可以看到137行和130行都有对v20[0]的赋值，简单猜测应该是进入了127行的循环

![image-20210410192332912](C:\Users\i\AppData\Roaming\Typora\typora-user-images\image-20210410192332912.png)

所以这里v20的值应该是v16，而且v16不能为0，我们继续回溯找v16。发现在110行，当v17为8的时候，v16 = v19.并且会直接跳出switch，所以v14，v15，v16都是根据v18的0~7,8~15,16~24而产生的。并且input_len不能超过32

接下来分两个分支看看v19和循环控制变量v44的走向

v19每次等于v18上的值+v13，v13等于v19左移8位，都是64位长的long long，v18则是一个指针，每次往后指一位。

v44？我凌乱了，只有一个给v44赋值的操作，还是初始化为0，但是观察到v44的声明在Input后面，怀疑是手写的输入函数，写入了Input后面的一个long long。暂时按这个猜测，因为scan函数分析起来略微复杂

不过往下看的时候发现如果有GXF，input_len（v44）是一个定长的30。 emm，不管了，先往下做。

（其实这里应该输入几次，动态调试看看的，但是我动态调试实在是第一次，完全没调懂，暂时放弃）。

接着分析v18, v18 = v8，并且len（暂且这么叫它吧）不能小于等于0，大于30，而v8是由输入的每一位循环异或一个table（循环节27位）

有一个判断85746060这个qw是不是大于16，去找一下它的交叉引用，发现这样一行“i_will_check_is_debug_or_not”，长度正合适，同时这个字符串被赋入table中，同时看上去6060这个判断对接下来的操作没有什么影响，我们返回主函数继续分析。

这个时候大体可以推出v20[0]的结构了，就是8个异或之后的字节拼到一起的一个int64，这是v16，我们正推一下v14、15都去了哪：最后到v42、v21，v20[3] = v18处理后的剩余位。而最后的处理所需的全部输入相关的变量我们已经推导出来，下面上z3约束求解。

四个变量分别是v20[0,1,2,3];

这个左移的顺序很好，解得v20直接每位异或回来就好了。对python的位运算不是很熟悉，我选择cpp

```python
from z3 import *

v0 = BitVec('v0', 64)
v1 = BitVec('v1', 64)
v2 = BitVec('v2', 64)
v3 = BitVec('v3', 64)

s = Solver()

#直接肉眼递归写表达式就好了
s.add(v2 & (~v0) == 0x11204161012)
s.add(v3 == 0x32310600)
s.add((v2 & (~v0)) | (v1 & v0) | (v2 & ~v1) | (v0 & ~v1) == 0x3E3A4717373E7F1F)
s.add(((v2 & ~v0) | (v1 & v0) | v1 & v2) == (~v0 & v2 | 0xC00020130082C0C))
s.add(v2 & (~v1) & v0 | v2 & (v1 & v0 | v1 & (~v0) | (~(v1 | v0))) == 0x8020717153E3013)


print(s.check())
print(s.model())
```

```cpp
#include <cstdio>
unsigned char s[] = {
	0x3e, 0x3a, 0x46, 0x05, 0x33, 0x28, 0x6f, 0x0d,
	0x0d, 0x44, 0x33, 0x5b, 0x30, 0x1b, 0x2c, 0x3e,
	0x08, 0x02, 0x07, 0x17, 0x15, 0x3e, 0x30, 0x13,
	0x32, 0x31, 0x06, 0x00
};
char table[] = "i_will_check_is_debug_or_not";
int main(){
	for(int i = 0; i < 28; i ++ ) s[i] ^= table[i%27];
	printf("%s\n", s);
}
```

然鹅，无论如何中间都有八位是不对的，也就是我的v1求出来的结果是错的。

翻了官方WP，发现它给定了v1的值。应该是比赛信息，但是BUU拿过来的时候没有写。。。

### Flag flag{We1l_D0ne!P0or_algebra_am_i}