---
title: BUUCTF 每日打卡 2021-4-23
date: 2021-04-23
tags:
---

# BUUCTF 每日打卡 2021-4-23

## 引言

无
## babyRSA
题目只给了 e, d, c
根据加密代码：

```python
from Crypto.Util.number import *
from flag import flag

def nextPrime(n):
    n += 2 if n & 1 else 1
    while not isPrime(n):
        n += 2
    return n

p = getPrime(1024)
q = nextPrime(p)
n = p * q
e = 0x10001
d = inverse(e, (p-1) * (q-1))
c = pow(bytes_to_long(flag.encode()), e, n)

```
我们得知 p 是一个 1024 位的素数，而 q 是 p 的下一个素数
所以，根据
$$
\varphi = (p-1)*(q-1)
$$
可以大致推断 $\varphi$ 介于 $(2^{1023})^2$ 与 $(2^{1024})^2$ 之间
根据
$$
e * d \equiv 1 \space (mod \space \varphi)
$$
推出 $\exists\space k \in\mathbb{Z}, \space s.t.$
$$
e * d = 1 +  k * \varphi
$$
再计算 $e * d - 1$ ，发现是一个 2066 位的数
可以推出 $k$ 是介于 $2^{15}$ 与 $2^{16}$ 之间的数
据此可以爆破出 $k$，然后得出 p, q ，完成解密
代码如下：

```python
from Crypto.Util.number import *
from gmpy2 import *
from sympy import *

d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913
c = 5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804
e = int('0x10001', 16)
kphi = e*d-1

print(len(bin(kphi)))
p = 0
q = 0
for k in range(pow(2, 15), pow(2, 16)):
    if kphi % k == 0:
        p = prevprime(iroot(kphi//k, 2)[0])
        q = nextprime(p)
        if (p-1)*(q-1)*k == kphi:
            break

n = p*q
m = pow(c, d, n)
print(long_to_bytes(m))
```

参考博客：[https://blog.csdn.net/weixin_45441024/article/details/110351394](https://blog.csdn.net/weixin_45441024/article/details/110351394)
## easyrsa
加密代码如下：

```python
from Crypto.Util.number import getPrime,bytes_to_long
from sympy import Derivative
from fractions import Fraction
from secret import flag

p=getPrime(1024)
q=getPrime(1024)
e=65537
n=p*q
z=Fraction(1,Derivative(arctan(p),p))-Fraction(1,Derivative(arth(q),q))
m=bytes_to_long(flag)
c=pow(m,e,n)
print(c,z,n)
```
特别的地方就是引入了一个 z
不管，先尝试[爆破](http://factordb.com/) n：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210423201754971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
啊这
让我爆破出来了
然后就是常规的 RSA 操作
代码如下：

```python
from Crypto.Util.number import *

p = 105909195259921349656664570904199242969110902804477734660927330311460997899731622163728968380757294196277263615386525795293086103142131020215128282050307177125962302515483190468569376643751587606016315185736245896434947691528567696271911398179288329609207435393579332931583829355558784305002360873458907029141
q = 144564833334456076455156647979862690498796694770100520405218930055633597500009574663803955456004439398699669751249623406199542605271188909145969364476344963078599240058180033000440459281558347909876143313940657252737586803051935392596519226965519859474501391969755712097119163926672753588797180811711004203301
n = 15310745161336895413406690009324766200789179248896951942047235448901612351128459309145825547569298479821101249094161867207686537607047447968708758990950136380924747359052570549594098569970632854351825950729752563502284849263730127586382522703959893392329333760927637353052250274195821469023401443841395096410231843592101426591882573405934188675124326997277775238287928403743324297705151732524641213516306585297722190780088180705070359469719869343939106529204798285957516860774384001892777525916167743272419958572055332232056095979448155082465977781482598371994798871917514767508394730447974770329967681767625495394441
c = 7922547866857761459807491502654216283012776177789511549350672958101810281348402284098310147796549430689253803510994877420135537268549410652654479620858691324110367182025648788407041599943091386227543182157746202947099572389676084392706406084307657000104665696654409155006313203957292885743791715198781974205578654792123191584957665293208390453748369182333152809882312453359706147808198922916762773721726681588977103877454119043744889164529383188077499194932909643918696646876907327364751380953182517883134591810800848971719184808713694342985458103006676013451912221080252735948993692674899399826084848622145815461035
e = 65537

phi = (p-1)*(q-1)
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
```
回过来我们揣测出题人引入 $z$ 的意图
首先
$$
z = \frac{1}{\frac{d(arctan(p))}{dp}} + \frac{1}{\frac{d(arth(q))}{dq}}
$$
又因为反正切函数和反双曲正切函数的导数分别为：
$$
\frac{d(arctan(x))}{dx} = \frac{1}{1 + x^{2}},\\
\frac{d(arth(x))}{dx} = \frac{1}{1 - x^{2}}
$$
所以
$$
z = \frac{1}{\frac{1}{1 + p^{2}}} + \frac{1}{\frac{1}{1 - q^{2}}}=p^{2} + q^{2}
$$
又因为 $n = p*q$，我们可以求出 $p + q$
再根据
$$
\varphi = (p-1)*(q-1) = p*q - p - q + 1 = n - (p+q) + 1
$$
可以求出 $\varphi$
然后进行解密
代码如下：

```python
from gmpy2 import *
from Crypto.Util.number import *

n = 15310745161336895413406690009324766200789179248896951942047235448901612351128459309145825547569298479821101249094161867207686537607047447968708758990950136380924747359052570549594098569970632854351825950729752563502284849263730127586382522703959893392329333760927637353052250274195821469023401443841395096410231843592101426591882573405934188675124326997277775238287928403743324297705151732524641213516306585297722190780088180705070359469719869343939106529204798285957516860774384001892777525916167743272419958572055332232056095979448155082465977781482598371994798871917514767508394730447974770329967681767625495394441
c = 7922547866857761459807491502654216283012776177789511549350672958101810281348402284098310147796549430689253803510994877420135537268549410652654479620858691324110367182025648788407041599943091386227543182157746202947099572389676084392706406084307657000104665696654409155006313203957292885743791715198781974205578654792123191584957665293208390453748369182333152809882312453359706147808198922916762773721726681588977103877454119043744889164529383188077499194932909643918696646876907327364751380953182517883134591810800848971719184808713694342985458103006676013451912221080252735948993692674899399826084848622145815461035
z = 32115748677623209667471622872185275070257924766015020072805267359839059393284316595882933372289732127274076434587519333300142473010344694803885168557548801202495933226215437763329280242113556524498457559562872900811602056944423967403777623306961880757613246328729616643032628964072931272085866928045973799374711846825157781056965164178505232524245809179235607571567174228822561697888645968559343608375331988097157145264357626738141646556353500994924115875748198318036296898604097000938272195903056733565880150540275369239637793975923329598716003350308259321436752579291000355560431542229699759955141152914708362494482
e = 65537

p_q = iroot(z + 2*n, 2)[0] # p+q
phi = n - p_q + 1
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
```
结果为：BJD{Advanced_mathematics_is_too_hard!!!}
高等数学太难了!!!（要不要来尝试数分高代呢）
## 结语
希望继续坚持