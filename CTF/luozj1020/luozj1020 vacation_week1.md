# 2021-7-14

## 四面八方

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714174137916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
看题干也看不出来什么
给了一个txt文件
key1:security
key2:information

密文啊这是，骚年加油：zhnjinhoopcfcuktlj
摸不着头脑
找wp，知道是没见过的[四方密码](https://zh.wikipedia.org/wiki/%E5%9B%9B%E6%96%B9%E5%AF%86%E7%A2%BC)
是一种对称加密，多表替换密码
找了一个靠谱的[在线工具](http://www.online.crypto-it.net/eng/four-square.html)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714174844185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
然后把结果换成小写套上flag就行

## [De1CTF2019]babyrsa

加密代码如下：

```python
import binascii
from data import e1,e2,p,q1p,q1q,hint,flag

n =  [20129615352491765499340112943188317180548761597861300847305827141510465619670536844634558246439230371658836928103063432870245707180355907194284861510906071265352409579441048101084995923962148527097370705452070577098780246282820065573711015664291991372085157016901209114191068574208680397710042842835940428451949500607613634682684113208766694028789275748528254287705759528498986306494267817198340658241873024800336013946294891687591013414935237821291805123285905335762719823771647853378892868896078424572232934360940672962436849523915563328779942134504499568866135266628078485232098208237036724121481835035731201383423L, 31221650155627849964466413749414700613823841060149524451234901677160009099014018926581094879840097248543411980533066831976617023676225625067854003317018794041723612556008471579060428898117790587991055681380408263382761841625714415879087478072771968160384909919958010983669368360788505288855946124159513118847747998656422521414980295212646675850690937883764000571667574381419144372824211798018586804674824564606122592483286575800685232128273820087791811663878057827386379787882962763290066072231248814920468264741654086011072638211075445447843691049847262485759393290853117072868406861840793895816215956869523289231421L, 29944537515397953361520922774124192605524711306753835303703478890414163510777460559798334313021216389356251874917792007638299225821018849648520673813786772452822809546571129816310207232883239771324122884804993418958309460009406342872173189008449237959577469114158991202433476710581356243815713762802478454390273808377430685157110095496727966308001254107517967559384019734279861840997239176254236069001453544559786063915970071130087811123912044312219535513880663913831358790376650439083660611831156205113873793106880255882114422025746986403355066996567909581710647746463994280444700922867397754748628425967488232530303L, 25703437855600135215185778453583925446912731661604054184163883272265503323016295700357253105301146726667897497435532579974951478354570415554221401778536104737296154316056314039449116386494323668483749833147800557403368489542273169489080222009368903993658498263905567516798684211462607069796613434661148186901892016282065916190920443378756167250809872483501712225782004396969996983057423942607174314132598421269169722518224478248836881076484639837343079324636997145199835034833367743079935361276149990997875905313642775214486046381368619638551892292787783137622261433528915269333426768947358552919740901860982679180791L]
c =  [19131432661217908470262338421299691998526157790583544156741981238822158563988520225986915234570037383888112724408392918113942721994125505014727545946133307329781747600302829588248042922635714391033431930411180545085316438084317927348705241927570432757892985091396044950085462429575440060652967253845041398399648442340042970814415571904057667028157512971079384601724816308078631844480110201787343583073815186771790477712040051157180318804422120472007636722063989315320863580631330647116993819777750684150950416298085261478841177681677867236865666207391847046483954029213495373613490690687473081930148461830425717614569L, 15341898433226638235160072029875733826956799982958107910250055958334922460202554924743144122170018355117452459472017133614642242411479849369061482860570279863692425621526056862808425135267608544855833358314071200687340442512856575278712986641573012456729402660597339609443771145347181268285050728925993518704899005416187250003304581230701444705157412790787027926810710998646191467130550713600765898234392350153965811595060656753711278308005193370936296124790772689433773414703645703910742193898471800081321469055211709339846392500706523670145259024267858368216902176489814789679472227343363035428541915118378163012031L, 18715065071648040017967211297231106538139985087685358555650567057715550586464814763683688299037897182845007578571401359061213777645114414642903077003568155508465819628553747173244235936586812445440095450755154357646737087071605811984163416590278352605433362327949048243722556262979909488202442530307505819371594747936223835233586945423522256938701002370646382097846105014981763307729234675737702252155130837154876831885888669150418885088089324534892506199724486783446267336789872782137895552509353583305880144947714110009893134162185382309992604435664777436197587312317224862723813510974493087450281755452428746194446L, 2282284561224858293138480447463319262474918847630148770112472703128549032592187797289965592615199709857879008271766433462032328498580340968871260189669707518557157836592424973257334362931639831072584824103123486522582531666152363874396482744561758133655406410364442174983227005501860927820871260711861008830120617056883514525798709601744088135999465598338635794275123149165498933580159945032363880613524921913023341209439657145962332213468573402863796920571812418200814817086234262280338221161622789516829363805084715652121739036183264026120868756523770196284142271849879003202190966150390061195469351716819539183797L]
f=lambda m,e,n,c:pow(m,e,n)==c
assert(sum(map(f,[p]*4,[4]*4,n,c))==4)

ee1 = 42
ee2 = 3
ce1 =  45722651786340123946960815003059322528810481841378247280642868553607692149509126962872583037142461398806689489141741494974836882341505234255325683219092163052843461632338442529011502378931140356111756932712822516814023166068902569458299933391973504078898958921809723346229893913662577294963528318424676803942288386430172430880307619748186863890050113934573820505570928109017842647598266634344447182347849367714564686341871007505886728393751147033556889217604647355628557502208364412269944908011305064122941446516990168924709684092200183860653173856272384
ce2 =  13908468332333567158469136439932325992349696889129103935400760239319454409539725389747059213835238373047899198211128689374049729578146875309231962936554403287882999967840346216695208424582739777034261079550395918048421086843927009452479936045850799096750074359160775182238980989229190157551197830879877097703347301072427149474991803868325769967332356950863518504965486565464059770451458557744949735282131727956056279292800694203866167270268988437389945703117070604488999247750139568614939965885211276821987586882908159585863514561191905040244967655444219603287214405014887994238259270716355378069726760953320025828158
tmp =  864078778078609835167779565982540757684070450697854309005171742813414963447462554999012718960925081621571487444725528982424037419052194840720949809891134854871222612682162490991065015935449289960707882463387
n  =  15911581555796798614711625288508309704791837516232122410440958830726078821069050404012820896260071751380436992710638364294658173571101596931605797509712839622479368850251206419748090059752427303611760004621378226431226983665746837779056271530181865648115862947527212787824629516204832313026456390047768174765687040950636530480549014401279054346098030395100387004111574278813749630986724706263655166289586230453975953773791945408589484679371854113457758157492241225180907090235116325034822993748409011554673180494306003272836905082473475046277554085737627846557240367696214081276345071055578169299060706794192776825039
assert(pow(e1,ee1,n)==ce1)
assert(pow(e2+tmp,ee2,n)==ce2)

e = 46531
n = 16278524034278364842964386062476113517067911891699789991355982121084973951738324063305190630865511554888330215827724887964565979607808294168282995825864982603759381323048907814961279012375346497781046417204954101076457350988751188332353062731641153547102721113593787978587135707313755661153376485647168543680503160420091693269984008764444291289486805840439906620313162344057956594836197521501755378387944609246120662335790110901623740990451586621846212047950084207251595169141015645449217847180683357626383565631317253913942886396494396189837432429078251573229378917400841832190737518763297323901586866664595327850603
c = 14992132140996160330967307558503117255626925777426611978518339050671013041490724616892634911030918360867974894371539160853827180596100892180735770688723270765387697604426715670445270819626709364566478781273676115921657967761494619448095207169386364541164659123273236874649888236433399127407801843412677293516986398190165291102109310458304626261648346825196743539220198199366711858135271877662410355585767124059539217274691606825103355310348607611233052725805236763220343249873849646219850954945346791015858261715967952461021650307307454434510851869862964236227932964442289459508441345652423088404453536608812799355469
hint=int(binascii.hexlify(hint),16)
assert(q1p*q1q==n)
assert(q1p<q1q)
assert(c==pow(hint,e,n))

flag=int(binascii.hexlify(flag),16)
q1=q1p
q2 =  114401188227479584680884046151299704656920536168767132916589182357583461053336386996123783294932566567773695426689447410311969456458574731187512974868297092638677515283584994416382872450167046416573472658841627690987228528798356894803559278308702635288537653192098514966089168123710854679638671424978221959513
c1 =  262739975753930281690942784321252339035906196846340713237510382364557685379543498765074448825799342194332681181129770046075018122033421983227887719610112028230603166527303021036386350781414447347150383783816869784006598225583375458609586450854602862569022571672049158809874763812834044257419199631217527367046624888837755311215081173386523806086783266198390289097231168172692326653657393522561741947951887577156666663584249108899327053951891486355179939770150550995812478327735917006194574412518819299303783243886962455399783601229227718787081785391010424030509937403600351414176138124705168002288620664809270046124
c2 =  7395591129228876649030819616685821899204832684995757724924450812977470787822266387122334722132760470911599176362617225218345404468270014548817267727669872896838106451520392806497466576907063295603746660003188440170919490157250829308173310715318925771643105064882620746171266499859049038016902162599261409050907140823352990750298239508355767238575709803167676810456559665476121149766947851911064706646506705397091626648713684511780456955453552020460909638016134124590438425738826828694773960514221910109473941451471431637903182205738738109429736425025621308300895473186381826756650667842656050416299166317372707709596
assert(c1==pow(flag,e1,p*q1))
assert(c2==pow(flag,e2,p*q2))
```

可以看出加密由三部分组成
先试着解密hint看看有什么提示

### hint解密

遇事不决，先尝试爆破n
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714212905119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
然后就是正常的RSA解密
代码如下：

```python
from Crypto.Util.number import *

e = 46531
n = 16278524034278364842964386062476113517067911891699789991355982121084973951738324063305190630865511554888330215827724887964565979607808294168282995825864982603759381323048907814961279012375346497781046417204954101076457350988751188332353062731641153547102721113593787978587135707313755661153376485647168543680503160420091693269984008764444291289486805840439906620313162344057956594836197521501755378387944609246120662335790110901623740990451586621846212047950084207251595169141015645449217847180683357626383565631317253913942886396494396189837432429078251573229378917400841832190737518763297323901586866664595327850603
c = 14992132140996160330967307558503117255626925777426611978518339050671013041490724616892634911030918360867974894371539160853827180596100892180735770688723270765387697604426715670445270819626709364566478781273676115921657967761494619448095207169386364541164659123273236874649888236433399127407801843412677293516986398190165291102109310458304626261648346825196743539220198199366711858135271877662410355585767124059539217274691606825103355310348607611233052725805236763220343249873849646219850954945346791015858261715967952461021650307307454434510851869862964236227932964442289459508441345652423088404453536608812799355469
q1p = 127587319253436643569312142058559706815497211661083866592534217079310497260365307426095661281103710042392775453866174657404985539066741684196020137840472950102380232067786400322600902938984916355631714439668326671310160916766472897536055371474076089779472372913037040153356437528808922911484049460342088834871
q1q = 127587319253436643569312142058559706815497211661083866592534217079310497260365307426095661281103710042392775453866174657404985539066741684196020137840472950102380232067786400322600902938984916355631714439668326671310160916766472897536055371474076089779472372913037040153356437528808922911484049460342088835693
phi = (q1q-1) * (q1p-1)
d = inverse(e, phi)
m = pow(c, d, n)
hint = long_to_bytes(m)
print(hint)
```

解密结果为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714213028344.png)
啊这
果然没那么简单吗
然后看第四部分，也就是加密flag的部分
其中q1p也就是q1已经爆破出来了
还有e1,e2和p未知
再看第二部分，也就是加密e1,e2的部分

### e1,e2解密

ee1和ee2比较小，可以采用**小公钥指数爆破**的方法
代码如下：

```python
import gmpy2

ee1 = 42
ee2 = 3
ce1 =  45722651786340123946960815003059322528810481841378247280642868553607692149509126962872583037142461398806689489141741494974836882341505234255325683219092163052843461632338442529011502378931140356111756932712822516814023166068902569458299933391973504078898958921809723346229893913662577294963528318424676803942288386430172430880307619748186863890050113934573820505570928109017842647598266634344447182347849367714564686341871007505886728393751147033556889217604647355628557502208364412269944908011305064122941446516990168924709684092200183860653173856272384
ce2 =  13908468332333567158469136439932325992349696889129103935400760239319454409539725389747059213835238373047899198211128689374049729578146875309231962936554403287882999967840346216695208424582739777034261079550395918048421086843927009452479936045850799096750074359160775182238980989229190157551197830879877097703347301072427149474991803868325769967332356950863518504965486565464059770451458557744949735282131727956056279292800694203866167270268988437389945703117070604488999247750139568614939965885211276821987586882908159585863514561191905040244967655444219603287214405014887994238259270716355378069726760953320025828158
tmp =  864078778078609835167779565982540757684070450697854309005171742813414963447462554999012718960925081621571487444725528982424037419052194840720949809891134854871222612682162490991065015935449289960707882463387
n  =  15911581555796798614711625288508309704791837516232122410440958830726078821069050404012820896260071751380436992710638364294658173571101596931605797509712839622479368850251206419748090059752427303611760004621378226431226983665746837779056271530181865648115862947527212787824629516204832313026456390047768174765687040950636530480549014401279054346098030395100387004111574278813749630986724706263655166289586230453975953773791945408589484679371854113457758157492241225180907090235116325034822993748409011554673180494306003272836905082473475046277554085737627846557240367696214081276345071055578169299060706794192776825039

for k in range(0, 100):
    a, b = gmpy2.iroot(ce1+k*n, ee1)
    if b == 1:
        e1 = a
        print(k)
        print('e1 =', e1)
        break
for k in range(0, 100000):
    a, b = gmpy2.iroot(ce2+k*n, ee2)
    if b == 1:
        e2 = a
        print(k)
        e2 -= tmp
        print('e2 =', e2)
        break
```

得到结果：
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021071421351490.png)
然后解密p

### p解密

加密p的部分提供了4对n和c
猜测应该采用**广播攻击**
使用广播攻击要满足n互素，否则失败，见[BUUCTF 每日打卡 2021-4-12](https://blog.csdn.net/weixin_52446095/article/details/115648034?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162626992416780264036681%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162626992416780264036681&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-115648034.pc_v2_rank_blog_default&utm_term=%E5%B9%BF%E6%92%AD&spm=1018.2226.3001.4450)
代码如下：

```python
import gmpy2

n =  [20129615352491765499340112943188317180548761597861300847305827141510465619670536844634558246439230371658836928103063432870245707180355907194284861510906071265352409579441048101084995923962148527097370705452070577098780246282820065573711015664291991372085157016901209114191068574208680397710042842835940428451949500607613634682684113208766694028789275748528254287705759528498986306494267817198340658241873024800336013946294891687591013414935237821291805123285905335762719823771647853378892868896078424572232934360940672962436849523915563328779942134504499568866135266628078485232098208237036724121481835035731201383423, 31221650155627849964466413749414700613823841060149524451234901677160009099014018926581094879840097248543411980533066831976617023676225625067854003317018794041723612556008471579060428898117790587991055681380408263382761841625714415879087478072771968160384909919958010983669368360788505288855946124159513118847747998656422521414980295212646675850690937883764000571667574381419144372824211798018586804674824564606122592483286575800685232128273820087791811663878057827386379787882962763290066072231248814920468264741654086011072638211075445447843691049847262485759393290853117072868406861840793895816215956869523289231421, 29944537515397953361520922774124192605524711306753835303703478890414163510777460559798334313021216389356251874917792007638299225821018849648520673813786772452822809546571129816310207232883239771324122884804993418958309460009406342872173189008449237959577469114158991202433476710581356243815713762802478454390273808377430685157110095496727966308001254107517967559384019734279861840997239176254236069001453544559786063915970071130087811123912044312219535513880663913831358790376650439083660611831156205113873793106880255882114422025746986403355066996567909581710647746463994280444700922867397754748628425967488232530303, 25703437855600135215185778453583925446912731661604054184163883272265503323016295700357253105301146726667897497435532579974951478354570415554221401778536104737296154316056314039449116386494323668483749833147800557403368489542273169489080222009368903993658498263905567516798684211462607069796613434661148186901892016282065916190920443378756167250809872483501712225782004396969996983057423942607174314132598421269169722518224478248836881076484639837343079324636997145199835034833367743079935361276149990997875905313642775214486046381368619638551892292787783137622261433528915269333426768947358552919740901860982679180791]
c =  [19131432661217908470262338421299691998526157790583544156741981238822158563988520225986915234570037383888112724408392918113942721994125505014727545946133307329781747600302829588248042922635714391033431930411180545085316438084317927348705241927570432757892985091396044950085462429575440060652967253845041398399648442340042970814415571904057667028157512971079384601724816308078631844480110201787343583073815186771790477712040051157180318804422120472007636722063989315320863580631330647116993819777750684150950416298085261478841177681677867236865666207391847046483954029213495373613490690687473081930148461830425717614569, 15341898433226638235160072029875733826956799982958107910250055958334922460202554924743144122170018355117452459472017133614642242411479849369061482860570279863692425621526056862808425135267608544855833358314071200687340442512856575278712986641573012456729402660597339609443771145347181268285050728925993518704899005416187250003304581230701444705157412790787027926810710998646191467130550713600765898234392350153965811595060656753711278308005193370936296124790772689433773414703645703910742193898471800081321469055211709339846392500706523670145259024267858368216902176489814789679472227343363035428541915118378163012031, 18715065071648040017967211297231106538139985087685358555650567057715550586464814763683688299037897182845007578571401359061213777645114414642903077003568155508465819628553747173244235936586812445440095450755154357646737087071605811984163416590278352605433362327949048243722556262979909488202442530307505819371594747936223835233586945423522256938701002370646382097846105014981763307729234675737702252155130837154876831885888669150418885088089324534892506199724486783446267336789872782137895552509353583305880144947714110009893134162185382309992604435664777436197587312317224862723813510974493087450281755452428746194446, 2282284561224858293138480447463319262474918847630148770112472703128549032592187797289965592615199709857879008271766433462032328498580340968871260189669707518557157836592424973257334362931639831072584824103123486522582531666152363874396482744561758133655406410364442174983227005501860927820871260711861008830120617056883514525798709601744088135999465598338635794275123149165498933580159945032363880613524921913023341209439657145962332213468573402863796920571812418200814817086234262280338221161622789516829363805084715652121739036183264026120868756523770196284142271849879003202190966150390061195469351716819539183797]
e = 4

for i in range(len(n)):
    for j in range(i+1, len(n)):
        if gmpy2.gcd(n[i], n[j]) != 1:
            p = gmpy2.gcd(n[i], n[j])
            k_p, k_q = i, j
            print(i, j)
            break
```

此题满足条件
先用sagemath封装好的CRT（中国剩余定理）解出$m^e$，代码如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714214240300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
最后开e次方得到m，也就是p
代码如下：

```python
import gmpy2

m_e = 146068806215073497344459876631371603884129554507314987227041386431864296983800292232765852493230146632246223391161616274352995602128509562953556195654254929572680238155614318159006433172894208760309766144817665852858474274746295434459658946786114485553768622540321693696983334739989582184316792317376817587284066141025953893816735983622448994863347051427279673308801466174898201800602688359956097373676655607179834345973775227535147398518523539179261883968140504230643073698857288314127486345168652339309386405706576632120711116391426300160476076254612138216623537070845645803721685414583459545099925250474009703135469241079408739336592005949980987466671054020054633554508243871664072158338203090563533576053886607251476483441992750608537110739543678599105838456537686029895264928334606913181627024815548789841726411333636163152202116487198575625907392074866811580053962217284776220330628233642351622897902940633662074194963147661868086182955886918339487179905557899816215131118989868243555958033477834658657082003718410617182774845820310639577794302769424451100567749840744304334325501306470124397022077759031911677326433654909824518845224227308515695216456907499080502091628962571645468099748573164070147303131348996440422701533681
x, y = gmpy2.iroot(m_e, e)
print(x, y)
p = x
```

得到结果：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714214419879.png)
最后解密flag

### flag解密

加密部分看似是普通的RSA加密，但是给了两个式子就很奇怪
尝试直接套RSA解密的话解出来是一堆乱码
解不出来找[wp](https://blog.csdn.net/weixin_44110537/article/details/1e7433092)才知道，这和普通的RSA有区别，其中$gcd(e_1,  p*q_1) = gcd(e_2,  p*q_2) = 14 \neq 1$
联想到之前解得一道[EzRSA](https://blog.csdn.net/weixin_52446095/article/details/117136443?spm=1001.2014.3001.5501)也是这种情况
仿照那道题发现开14次方不能开出来
参照[另一个wp](https://www.codenong.com/cs109681910/)（其实就是对之前那个wp的解释，但是之前那个没怎么看懂），给出解法
$$
\begin{cases}
c_1 \equiv m^{e_1} \space mod \space p*q_1\\
c_2 \equiv m^{e_2} \space mod \space p*q_2
\end{cases}
\Rightarrow
\begin{cases}
c_1 \equiv m^{14*(\frac{e_{1}}{14})} \space mod \space p*q_1\\
c_2 \equiv m^{14*(\frac{e_{2}}{14})} \space mod \space p*q_2
\end{cases}
$$
而$gcd(\frac{e_{1}}{14},  p*q_1) = gcd(\frac{e_{2}}{14},  p*q_2) =1$
所以$m^{14} \equiv c_{1}^{d_1}  \space mod \space p*q_1$，其中$\frac{e_{1}}{14}*d_1 \equiv 1\space mod \space p*q_1$
同理，有$m^{14} \equiv c_{2}^{d_2}  \space mod \space p*q_2$，其中$\frac{e_{2}}{14}*d_2 \equiv 1\space mod \space p*q_2$
此时可以用中国剩余定理求出一个特解,但是不是最终解，是因为$gcd(14, p-1)=14$亦即$p-1$是14的整数倍，所以会失败
于是将上两式拆成四式：
$$
\begin{cases}
m^{14} \equiv c_{1}^{d_1}  \space mod \space p \cdots(1)\\
m^{14} \equiv c_{1}^{d_1}  \space mod \space q_1 \cdots(2)\\
m^{14} \equiv c_{2}^{d_2}  \space mod \space p \cdots(3)\\
m^{14} \equiv c_{2}^{d_2}  \space mod \space q_2 \cdots(4)
\end{cases}
$$
选择不含$p$的式子，亦即(2)和(4)式用中国剩余定理
代码如下：

```python
from Crypto.Util.number import *
import gmpy2

q1 = q1p
q2 =  114401188227479584680884046151299704656920536168767132916589182357583461053336386996123783294932566567773695426689447410311969456458574731187512974868297092638677515283584994416382872450167046416573472658841627690987228528798356894803559278308702635288537653192098514966089168123710854679638671424978221959513
c1 =  262739975753930281690942784321252339035906196846340713237510382364557685379543498765074448825799342194332681181129770046075018122033421983227887719610112028230603166527303021036386350781414447347150383783816869784006598225583375458609586450854602862569022571672049158809874763812834044257419199631217527367046624888837755311215081173386523806086783266198390289097231168172692326653657393522561741947951887577156666663584249108899327053951891486355179939770150550995812478327735917006194574412518819299303783243886962455399783601229227718787081785391010424030509937403600351414176138124705168002288620664809270046124
c2 =  7395591129228876649030819616685821899204832684995757724924450812977470787822266387122334722132760470911599176362617225218345404468270014548817267727669872896838106451520392806497466576907063295603746660003188440170919490157250829308173310715318925771643105064882620746171266499859049038016902162599261409050907140823352990750298239508355767238575709803167676810456559665476121149766947851911064706646506705397091626648713684511780456955453552020460909638016134124590438425738826828694773960514221910109473941451471431637903182205738738109429736425025621308300895473186381826756650667842656050416299166317372707709596

phi1 = (p-1) * (q1-1)
phi2 = (p-1) * (q2-1)
print(gmpy2.gcd(e1, phi1)) # 14
print(gmpy2.gcd(e2, phi2)) # 14
d1 = inverse(e1//14, phi1)
d2 = inverse(e2//14, phi2)
print(pow(c1, d1, q1), pow(c2, d2, q2))
```

先用sagemath封装好的CRT（中国剩余定理）解出$m^14$，代码如下：m
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714223500633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
再用$m^{14},q1,q2$求出$m^2$，再开平方得到$m$
代码如下：

```python
m14 = 3580483299432395573659317753435578327637985357646700589244795353763573715336139257763207735764180027583647775608064149038853113096146443168864525876633843358404759038299549652788731401504933571857458579919657482494694530749880548630064266049810247928643334919438340898675734894238176854701817798193943787788697804563837637936347825096631189269242445925193015122262187618001159858028229304823201669018674562259904808285226405200475644934113919993329694127412750568776255266590650092290392749263011086241948791335363230476476351250684647853369997799237573793567577022116859682785257602832495614664192557787307332769009
d = inverse(7, (q1-1) * (q2-1))
m2 = pow(m14, d, q1*q2)
print(gmpy2.iroot(m2, 2))
m = gmpy2.iroot(m2, 2)[0]
print(long_to_bytes(m))
print(gmpy2.gcd(14, (p-1)))
```

最后结果为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021071422382682.png)
这是一道很综合的RSA，难点主要集中再最后一步

# 2021-7-15

## [MRCTF2020]Easy_RSA

加密代码如下：

```python
import sympy
from gmpy2 import gcd, invert
from random import randint
from Crypto.Util.number import getPrime, isPrime, getRandomNBitInteger, bytes_to_long, long_to_bytes
import base64

from zlib import *
flag = b"MRCTF{XXXX}"
base = 65537

def gen_prime(N):
    A = 0
    while 1:
        A = getPrime(N)
        if A % 8 == 5:
            break
    return A

def gen_p():
    p = getPrime(1024)
    q = getPrime(1024)
    assert (p < q)
    n = p * q
    print("P_n = ", n)
    F_n = (p - 1) * (q - 1)
    print("P_F_n = ", F_n)
    factor2 = 2021 * p + 2020 * q
    if factor2 < 0:
        factor2 = (-1) * factor2
    return sympy.nextprime(factor2)


def gen_q():
    p = getPrime(1024)
    q = getPrime(1024)
    assert (p < q)
    n = p * q
    print("Q_n = ", n)
    e = getRandomNBitInteger(53)
    F_n = (p - 1) * (q - 1)
    while gcd(e, F_n) != 1:
        e = getRandomNBitInteger(53)
    d = invert(e, F_n)
    print("Q_E_D = ", e * d)
    factor2 = 2021 * p - 2020 * q
    if factor2 < 0:
        factor2 = (-1) * factor2
    return sympy.nextprime(factor2)


if __name__ == "__main__":
    _E = base
    _P = gen_p()
    _Q = gen_q()
    assert (gcd(_E, (_P - 1) * (_Q - 1)) == 1)
    _M = bytes_to_long(flag)
    _C = pow(_M, _E, _P * _Q)
    print("Ciphertext = ", _C)
'''
P_n =  14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024336556028267742021320891681762543660468484018686865891073110757394154024833552558863671537491089957038648328973790692356014778420333896705595252711514117478072828880198506187667924020260600124717243067420876363980538994101929437978668709128652587073901337310278665778299513763593234951137512120572797739181693
P_F_n =  14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024099427363967321110127562039879018616082926935567951378185280882426903064598376668106616694623540074057210432790309571018778281723710994930151635857933293394780142192586806292968028305922173313521186946635709194350912242693822450297748434301924950358561859804256788098033426537956252964976682327991427626735740
Q_n =  20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947
Q_E_D =  100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201
Ciphertext =  40855937355228438525361161524441274634175356845950884889338630813182607485910094677909779126550263304194796000904384775495000943424070396334435810126536165332565417336797036611773382728344687175253081047586602838685027428292621557914514629024324794275772522013126464926990620140406412999485728750385876868115091735425577555027394033416643032644774339644654011686716639760512353355719065795222201167219831780961308225780478482467294410828543488412258764446494815238766185728454416691898859462532083437213793104823759147317613637881419787581920745151430394526712790608442960106537539121880514269830696341737507717448946962021
'''
```

事实上，这种题目吓唬人的成分很大，只要仔细看就能解出来
比如给的第一个函数```gen_prime````完全没有用到
后面的P_n和Q_n也可以爆破出来，然后照着他的加密方法解出P和Q，P_F_n和Q_E_D完全没有用到
最后就是常规的RSA了
解密代码如下：

```python
from Crypto.Util.number import *
import sympy

P_n =  14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024336556028267742021320891681762543660468484018686865891073110757394154024833552558863671537491089957038648328973790692356014778420333896705595252711514117478072828880198506187667924020260600124717243067420876363980538994101929437978668709128652587073901337310278665778299513763593234951137512120572797739181693
P_F_n =  14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024099427363967321110127562039879018616082926935567951378185280882426903064598376668106616694623540074057210432790309571018778281723710994930151635857933293394780142192586806292968028305922173313521186946635709194350912242693822450297748434301924950358561859804256788098033426537956252964976682327991427626735740
Q_n =  20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947
Q_E_D =  100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201
Ciphertext =  40855937355228438525361161524441274634175356845950884889338630813182607485910094677909779126550263304194796000904384775495000943424070396334435810126536165332565417336797036611773382728344687175253081047586602838685027428292621557914514629024324794275772522013126464926990620140406412999485728750385876868115091735425577555027394033416643032644774339644654011686716639760512353355719065795222201167219831780961308225780478482467294410828543488412258764446494815238766185728454416691898859462532083437213793104823759147317613637881419787581920745151430394526712790608442960106537539121880514269830696341737507717448946962021
_E = 65537

# P
P_p = 118153578345562250550767057731385782963063734586321112579869747650001448473633860305142281504862521928246520876300707405515141444727550839066835195905927281903880307860942630322499106164191736174201506457157272220802515607939618476716593888428832962374494147723577980992661629254713116923690067827155668889571
P_q = 118975085954858660642562584152139261422493348532593400307960127317249511761542030451912561362687361053191375307180413931721355251895350936376781657674896801388806379750757264377396608174235075021854614328009897408824235800167369204203680938298803752964983358298299699273425596382268869237139724754214443556383
P = sympy.nextprime(2021 * P_p + 2020 * P_q)
print(P)

# Q
Q_p = 120538849514661970159855851547577637711900368732462953774738483480759950867244867240401273864984981385806453735655967797329769252143125966966236767391995563418243748302685348336642872306042286401427581501609713577329945760930395130411743322595026287853073310150103535873078436896035943385067893062698858976291
Q_q = 171847486694659608706336923173786708071603689972942289760669690002615525263534483261477699540482615520223300780778172120221008417518590133753701145591943840552802072474293556608389677806415392384924913911677288126066245025731416399656855625839288752326267741979436855441260177305707529456715625062080892327017
Q = 2021 * Q_p - 2020 * Q_q
if Q < 0:
    Q = (-1) * Q
Q = sympy.nextprime(Q)
print(Q)

# flag
D = inverse(_E, (P-1)*(Q-1))
M = pow(Ciphertext, D, P*Q)
print(long_to_bytes(M))
```

结果为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210715085823295.png)

## [ACTF新生赛2020]crypto-aes

加密代码如下：

```python
from Cryptodome.Cipher import AES
import os
import gmpy2
from flag import FLAG
from Cryptodome.Util.number import *

def main():
    key=os.urandom(2)*16
    iv=os.urandom(16)
    print(bytes_to_long(key)^bytes_to_long(iv))
    aes=AES.new(key,AES.MODE_CBC,iv)
    enc_flag = aes.encrypt(FLAG)
    print(enc_flag)
if __name__=="__main__":
    main()
```

AES基本没有了解过，以前尝试看了加密函数的[官方文档]，没怎么看明白(https://pycryptodome.readthedocs.io/en/latest/src/cipher/aes.html)
只能找[wp](https://blog.csdn.net/MikeCoke/article/details/113790052)
如果只是解题的话，只需要利用

```python
aes = AES.new(key,AES.MODE_CBC,iv)
flag = aes.decrypt(enc_flag)
```

两句代码即可，关键是解出**key**（密钥）和**iv**（初始化向量）
可以看到key是由8个重复的随机生成的2bytes,16bits的字符串组成32bytes,256bits字符串，iv则是随机生成16bytes,128bits的字符串
已知key与iv做异或运算得到的结果，所以key的前16bytes字符是不变的，由此可以推断出key
再用key后16bytes与异或的结果进行异或运算可以得到iv
解密代码如下：

```python
from Crypto.Util.number import *
from Crypto.Cipher import AES

xor = 91144196586662942563895769614300232343026691029427747065707381728622849079757
enc_flag = b'\x8c-\xcd\xde\xa7\xe9\x7f.b\x8aKs\xf1\xba\xc75\xc4d\x13\x07\xac\xa4&\xd6\x91\xfe\xf3\x14\x10|\xf8p'

key = long_to_bytes(xor)[:16] * 2
print(key)
iv = bytes_to_long(long_to_bytes(xor)[16:]) ^ bytes_to_long(key[16:])
iv = long_to_bytes(iv)
aes = AES.new(key, AES.MODE_CBC, iv)
flag = aes.decrypt(enc_flag)
print(flag)
```

结果为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210715170341760.png)

# 2021-7-16

## [UTCTF2020]hill

hill？山丘？变异栅栏？
没有头绪，找[wp](https://blog.csdn.net/weixin_44110537/article/details/107450336)
原来是[希尔密码](https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E5%AF%86%E7%A0%81)，没见过
主要就是要求一个nxn的密钥矩阵，然后解密即可
从wp中得知utflag被加密成wznqca，只能构造6个式子，还要模26，所以不可能是3x3的矩阵，只有可能是2x2的矩阵，4个未知数
即
$$
\begin{pmatrix}a & b \\ c & d \end{pmatrix}\begin{pmatrix}20 & 5 & 0 \\19 & 11 & 6  \end{pmatrix}\equiv \begin{pmatrix}22 & 13 & 2 \\25 & 16 & 0  \end{pmatrix}mod\space 26
$$
其中$a,b,c,d$为密钥矩阵的四个未知数
得到模方程组
$$
\begin{cases}
20a+19b\equiv 22\space mod\space 26\\
20c+19d\equiv 25\space mod\space 26\\
5a+11b\equiv 13\space mod\space 26\\
5c+11d\equiv 16\space mod\space 26\\
6b\equiv 2\space mod\space 26\\
6d\equiv 0\space mod\space 26
\end{cases}
$$
显然，最后两个式子是最好下手的，但是我没有什么好的方法，猜测$a,b,c,d$应该不会超过100，干脆直接爆破，代码如下：

```python
import random

for k in range(0, 100):
    a = 0; b = 0; c = 0; d = 0

    while (20*a+19*b) % 26 != 22 or (20*c+19*d) % 26 != 25:
        d = random.randint(0, 100)
        b = random.randint(0, 100)
        a = 0
        c = 0
        while (6*d) % 26 != 0:
            d += 1
        while (5*c+11*d) % 26 != 16:
            c += 1
        while (6*b) % 26 != 2:
            b += 1
        while (5*a+11*b) % 26 != 13:
            a += 1
    print(a, b, c, d)

    with open('result.txt', 'r') as f:
        r = f.readlines()

    with open('result.txt', 'a') as f:
        if not (str([a, b, c, d]) + '\n') in r:
            f.write(str([a, b, c, d]) + '\n')
```

得到了100以内的部分解：

```python
[1, 22, 11, 91]
[1, 22, 11, 39]
[1, 100, 11, 39]
[1, 100, 11, 91]
[1, 48, 11, 39]
[1, 48, 11, 65]
[1, 74, 11, 39]
[1, 22, 11, 13]
[1, 100, 11, 65]
[1, 74, 11, 65]
[1, 74, 11, 13]
[1, 74, 11, 91]
[1, 22, 11, 65]
[1, 100, 11, 13]
[1, 48, 11, 91]
[1, 48, 11, 13]
```

猜测密钥矩阵可能不唯一
懒得自己写解密程序了，就找了一个[在线工具](http://practicalcryptography.com/ciphers/hill-cipher/)
验证了前三组，结果相同，证实了我的猜想
结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210716212550574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
忽略了符号、数字和大小写，修改一下即可
结果为```utflag{d4nger0us_c1pherText_qq}```

## [INSHack2017]rsa16m

题干描述：
When you need really secure communications, you use RSA with a 4096 bit key. 
I want really really really secure communications to transmit the nuclear launch codes (yeah IoT is everywhere man) so I used RSA with a 16777216 bit key. Surely russians will not be able to factor that one ! 

平时为了保证安全RSA会采用4096位的密钥，但他给我整了个16777216位的
wtm直接找[wp](https://blog.csdn.net/weixin_44110537/article/details/107623082)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210716213545322.png)
啊这
这还真想不到
代码如下：

```python
import gmpy2
from Crypto.Util.number import *

c = # 自己复制
e = 0x10001
m = gmpy2.iroot(c, e)[0]

print(long_to_bytes(m))
```

结果为
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021071621391856.png)

# 2021-7-17

## [INSHack2019]Yet Another RSA Challenge - Part 1

加密代码如下：

```python
import subprocess
p = subprocess.check_output('openssl prime -generate -bits 2048 -hex')
q = subprocess.check_output('openssl prime -generate -bits 2048 -hex')
flag = int('INSA{REDACTED}'.encode('hex'), 16)

N = int(p,16) * int(q,16)
print N
print '0x'+p.replace('9F','FC')
print pow(flag,65537,N)
```

其实就是随机生成p,q，然后常规RSA加密，就是输出的时候对p进行了一些小的改动
解题时不能确定原来的p是否也含有“FC”，所以不能直接替换回去，要遍历所有情况，符合条件的p应当整除N
写了一个简陋的递归程序来解密：

```python
from Crypto.Util.number import *

N = 719579745653303119025873098043848913976880838286635817351790189702008424828505522253331968992725441130409959387942238566082746772468987336980704680915524591881919460709921709513741059003955050088052599067720107149755856317364317707629467090624585752920523062378696431510814381603360130752588995217840721808871896469275562085215852034302374902524921137398710508865248881286824902780186249148613287250056380811479959269915786545911048030947364841177976623684660771594747297272818410589981294227084173316280447729440036251406684111603371364957690353449585185893322538541593242187738587675489180722498945337715511212885934126635221601469699184812336984707723198731876940991485904637481371763302337637617744175461566445514603405016576604569057507997291470369704260553992902776099599438704680775883984720946337235834374667842758010444010254965664863296455406931885650448386682827401907759661117637294838753325610213809162253020362015045242003388829769019579522792182295457962911430276020610658073659629786668639126004851910536565721128484604554703970965744790413684836096724064390486888113608024265771815004188203124405817878645103282802994701531113849607969243815078720289912255827700390198089699808626116357304202660642601149742427766381
p = '0xDCC5A0BD3A1FC0BEB0DA1C2E8CF6B474481B7C12849B76E03C4C946724DB577D2825D6AA193DB559BC9DBABE1DDE8B5E7805E48749EF002F622F7CDBD7853B200E2A027E87E331AFCFD066ED9900F1E5F5E5196A451A6F9E329EB889D773F08E5FBF45AACB818FD186DD74626180294DCC31805A88D1B71DE5BFEF3ED01F12678D906A833A78EDCE9BDAF22BBE45C0BFB7A82AFE42C1C3B8581C83BF43DFE31BFD81527E507686956458905CC9A660604552A060109DC81D01F229A264AB67C6D7168721AB36DE769CEAFB97F238050193EC942078DDF5329A387F46253A4411A9C8BB71F9AEB11AC9623E41C14FCD2739D76E69283E57DDB11FC531B4611EE3'
c = 596380963583874022971492302071822444225514552231574984926542429117396590795270181084030717066220888052607057994262255729890598322976783889090993129161030148064314476199052180347747135088933481343974996843632511300255010825580875930722684714290535684951679115573751200980708359500292172387447570080875531002842462002727646367063816531958020271149645805755077133231395881833164790825731218786554806777097126212126561056170733032553159740167058242065879953688453169613384659653035659118823444582576657499974059388261153064772228570460351169216103620379299362366574826080703907036316546232196313193923841110510170689800892941998845140534954264505413254429240789223724066502818922164419890197058252325607667959185100118251170368909192832882776642565026481260424714348087206462283972676596101498123547647078981435969530082351104111747783346230914935599764345176602456069568419879060577771404946743580809330315332836749661503035076868102720709045692483171306425207758972682717326821412843569770615848397477633761506670219845039890098105484693890695897858251238713238301401843678654564558196040100908796513657968507381392735855990706254646471937809011610992016368630851454275478216664521360246605400986428230407975530880206404171034278692756
e = 65537

def join_p(tmp, s, l):
    s += tmp[0]
    if s[-2:] == 'E3':
        l.append(s)
        # print(s)
    for c in ['FC', '9F']:
        if s[-2:] == 'FC':
            s = s[:-2]
        s += c
        if len(tmp) > 1:
            join_p(tmp[1:], s, l)
    return l

tmp = p.split('FC')
list_p = join_p(tmp, '', [])
for _p in list_p:
    if N % int(_p, 16) == 0:
        p = int(_p, 16)
        print(p)
        break
q = N//p
phi = (p-1)*(q-1)
d = inverse(e, phi)
m = pow(c, d, N)
print(long_to_bytes(m))
```

结果为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717214230100.png)

## [AFCTF2018]花开藏宝地

题干描述如下：
第80804238007977405688648566160504278593148666302626415149704905628622876270862865768337953835725801963142685182510812938072115996355782396318303927020705623120652014080032809421180400984242061592520733710243483947230962631945045134540159517488288781666622635328316972979183761952842010806304748313326215619695085380586052550443025074501971925005072999275628549710915357400946408857号藏宝图

我把我的宝藏都藏在了那里！
那个神秘的地方！
于是我把藏宝图分成了5份，交给五位贤者让他们帮我妥善保管，并且只要搜集3份就可以获得宝藏的地址。

第一位贤者将藏宝图放进时空门中说道：
“那么口令就是我的生日吧，那可是个好数字呢。”

第二位贤者将藏宝图放进宝箱，【小】声念着自己的名字锁上了宝箱。

第三位贤者将藏宝图施上咒语丢进大海：“只要【大】声喊出那句咒语就可以把水驱逐！”

第四位贤者找了个破锁锁上了宝箱，狡黠地笑着：“谁知道它是坏的呢？”

第五位贤者给藏宝图裹上了隐身衣，放入了一个匣子里

据说，只有拥有【智慧】与【力量】就可以获得宝藏了呢！~
你是这样的勇者吗？

题目给了五个压缩包，只要搞出三个就行
前三个都可以爆破密码
爆破工具链接详见我[2021-4-25的博客](https://blog.csdn.net/weixin_52446095/article/details/116139873?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162653002016780357231951%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162653002016780357231951&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-3-116139873.pc_v2_rank_blog_default&utm_term=%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%AF%86%E7%A0%81&spm=1018.2226.3001.4450)
第一个提示是生日，应当为8位数字密码
爆破结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717214846148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
第二个提示是小写名字
爆破结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717215005131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
第三个提示是大写咒语
爆破结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717215153129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
第四个是伪加密，参考我[2021-4-19的博客](https://blog.csdn.net/weixin_52446095/article/details/115875059?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162653022716780269884646%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162653022716780269884646&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-115875059.pc_v2_rank_blog_default&utm_term=%E4%BC%AA%E5%8A%A0%E5%AF%86&spm=1018.2226.3001.4450)
只要把如下图所示位置改成偶数即可
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717215930465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
第5个根据[官方wp](https://csuwangj.github.io/afctf2018-crypto-officialwriteup/)是NTFS隐写
但是我解压rar文件之后拿ntfsstreamseditor怎么扫都扫不出流文件，我以为是ntfsstreamseditor的问题，然后换了个工具叫AlternateStreamView，也扫不出来
后来又找了一些资料，发现解压工具用的都是WinRAR，而我用的是BandZip
改用WinRAR解压后，就能扫出来了
AlternateStreamView界面如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717224350633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
之后点导出然后确定即可
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021071722445797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
附上ntfsstreamseditor的[下载地址](https://pan.baidu.com/share/link?shareid=111913189&uk=741348754&_at_=1626514741168)和AlternateStreamView的[
下载地址](http://www.nirsoft.net/utils/alternate_data_streams.html)以及WinRAR的[下载地址](https://www.win-rar.com/download.html?&L=0)

得到的文件都是一对(x,m)，不知道是干什么的
看了[一个大佬的wp](https://shawroot.hatenablog.com/entry/2019/12/26/AFCTF2018/BUUCTF-Crypto:%E8%8A%B1%E5%BC%80%E8%97%8F%E5%AE%9D%E5%9C%B0)之后知道是[门限方案](https://webencrypt.org/secretsharing/)
而题目提示“花开(bloom)”暗指Asmuth-Bloom门限方案
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717225140913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
首先是传统艺能sagemath中国剩余定理(CRT)：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717225440444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
5对(x,m)全用上结果是一样的：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717225534515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
然后p即为第几号藏宝图
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021071723072279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
如上图所示，由于$y<p$，所以只需将$y'(CRT的结果)-Ap$模$p$即可得到$S$（密文）了
代码如下：

```python
from Crypto.Util.number import *

x1 = 305345133911395218573790903508296238659147802274031796643017539011648802808763162902335644195648525375518941848430114497150082025133000033835083076541927530829557051524161069423494451667848236452337271862085346869364976989047180532167560796470067549915390773271207901537847213882479997325575278672917648417868759077150999044891099206133296336190476413164240995177077671480352739572539631359
m1 = 347051559622463144539669950096658163425646411435797691973701513725701575100810446175849424000000075855070430240507732735393411493866540572679626172742301366146501862670272443070970511943485865887494229487420503750457974262802053722093905126235340380261828593508455621667309946361705530667957484731929151875527489478449361198648310684702574627199321092927111137398333029697068474762820813413
x2 = 152012681270682340051690627924586232702552460810030322267827401771304907469802591861912921281833890613186317787813611372838066924894691892444503039545946728621696590087591246339208248647926966446848123290344911662916758039134817404720512465817867255277476717353439505243247568126193361558042940352204093381260402400739429050280526212446967632582771424597203000629197487733610187359662268583
m2 = 347051559622463144539669950096658163425646411435797691973701513725701575100810446175849424000000075855070430240507732735393411493866540572679626172742301366146501862670272443070970511943485865887494229487420503750457974262802053722093905126235340380261828593508455621667309946361705530667957484731929151875527489478449361198648310684702574627199321092927111137398333029697068474762820818553
x3 = 40952412095267791829743119118333311932687870987919948671780408726886151430242690997238831410249436653299224291445012397813221016909468630372862610415470277301591535416193017906909638241212666990959976187895288689640250810487806568164431359887246760313154046201720715301307811951233077581047872827004824833876458687145628724339714212107812941785880896399800008924818580623979723496070665230
m3 = 347051559622463144539669950096658163425646411435797691973701513725701575100810446175849424000000075855070430240507732735393411493866540572679626172742301366146501862670272443070970511943485865887494229487420503750457974262802053722093905126235340380261828593508455621667309946361705530667957484731929151875527489478449361198648310684702574627199321092927111137398333029697068474762820819351
x4 = 100459779913520540098065407420629954816677926423356769524759072632219106155849450125185205557491138357760494272691949199099803239098119602186117878931534968435982565071570831032814288620974807498206233914826253433847572703407678712965098320122549759579566316372220959610814573945698083909575005303253205653244238542300266460559790606278310650849881421791081944960157781855164700773081375247
m4 = 347051559622463144539669950096658163425646411435797691973701513725701575100810446175849424000000075855070430240507732735393411493866540572679626172742301366146501862670272443070970511943485865887494229487420503750457974262802053722093905126235340380261828593508455621667309946361705530667957484731929151875527489478449361198648310684702574627199321092927111137398333029697068474762820820091
x5 = 230502064382947282343660159791611936696520807970361139469603458689311286041516767875903549263861950740778705012699983268093626403307298415066249636346303539570207577050391796770068203937723627361951969413683246596072925692670365490970847825269581004483964261491917680759091791653759514213188778401968676433284753781006738293752440186858616315727565803777032119737689210471541053061940547213
m5 = 347051559622463144539669950096658163425646411435797691973701513725701575100810446175849424000000075855070430240507732735393411493866540572679626172742301366146501862670272443070970511943485865887494229487420503750457974262802053722093905126235340380261828593508455621667309946361705530667957484731929151875527489478449361198648310684702574627199321092927111137398333029697068474762820822249
x = [x1, x2, x3]
m = [m1, m2, m3]

p = 80804238007977405688648566160504278593148666302626415149704905628622876270862865768337953835725801963142685182510812938072115996355782396318303927020705623120652014080032809421180400984242061592520733710243483947230962631945045134540159517488288781666622635328316972979183761952842010806304748313326215619695085380586052550443025074501971925005072999275628549710915357400946408857
_m = 30876976368086692285558250036880406604917636310753345643851443311621560437660524037995161241308442036379469552063806443002181224753860983594447977830810170201541624128881271226685934621113368082630765925118134834325144756352463621990490982075331418652446742943160748740071265060573720998451298794523954529649159404329795707381755731242527536198482385928070127829060902084889604193497570570666454987614622192127799628914721314092255874223423836747903381309023217090349405981222877770048197886205341954349001378037043986104483577949386469631664327951317484659223470641035291599627126044129328116138456709005193822302098284284434695284085356908092040649892546733042792734012082009931947240120686605195896740999916349434920823829741045025395035620492258352790658333703219086923204432403214249952956353508095035923172933873864816804322018707765332798796032165097476986184856220405455000518836225976464413270841989241690755609748164301706451818506613253021035612120841991720836023832195539291404838851109196963155279844798918459609655314345181964484399235640350608446994546531900893730936604087604005537829207389277430878456169931854713629162410944416019365035094299249030737
print(long_to_bytes(_m % p))
```

结果为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717230947544.png)

# 2021-7-18

## [GUET-CTF2019]NO SOS

给了个附件：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210718110454617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
摩斯电码？
但是又没有分隔符
还有这些长短不一的点和横是怎么回事
NO SOS?是没有'S'和'O'的意思吗？
没想法，找[wp](https://blog.csdn.net/weixin_44110537/article/details/107569609)
原来 NO SOS 是暗示这不是摩尔斯电码，要把'.'和'-'分别替换成'a'和'b'搞成培根密码（反正我是想不到的）
解密代码如下：

```python
c = '..-.-.-.–…….–..-…-..-…–.-.-….-..-..–.-.-..-.-..—-'.replace('…', '...').replace('—', '---').replace('–', '--')

print(c.replace('.', 'a').replace('-', 'b'))
print(c.replace('.', 'b').replace('-', 'a'))
```

要记得把不同长度换成相同长度的
然后找了个[在线工具](https://tool.bugku.com/peigen/)解密
其中第一个是正解
结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210718111126603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)

## [QCTF2018]Xman-RSA

这题可以说是相当爱折腾
一上来给了四个附件
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210718111233207.png)
前三个文件都是密文
第四个文件是加密的加密程序（啊这）

```python
gqhb jbkl2 pbkhqw pt_kqpbd
gqhb ht pbkhqw zqreahb
pbkhqw urtd64

adg ulwdt_wh_ezb(u):
	qdwzqe pew(u.dexhad('mdi'), 16)
	
adg ezb_wh_ulwdt(e):
	u = mdi(e)[2:-1]
	u = '0' + u pg yde(u)%2 == 1 dytd u
	qdwzqe u.adxhad('mdi')

adg jdw_r_kqpbd(y):
	qreahb_tdda = zqreahb(y)

	ezb = ulwdt_wh_ezb(qreahb_tdda)
	
	fmpyd Tqzd:
		pg pt_kqpbd(ezb):
			uqdrv
		ezb+=1
	qdwzqe ezb

adg dexqlkw(t, d, e):
	k = ulwdt_wh_ezb(t)
	k = khf(k, d, e)
	qdwzqe ezb_wh_ulwdt(k).dexhad('mdi')	

adg tdkrqrwd(e):
	k = e % 4
	w = (k*k) % 4
	qdwzqe w == 1
	
g = hkde('gyrj.wiw', 'q')
gyrj = g.qdra()
		
btj1 = ""
btj2 = ""
ghq p pe qrejd(yde(gyrj)):
	pg tdkrqrwd(p):
		btj2 += gyrj[p]
	dytd:
		btj1 += gyrj[p]

k1 = jdw_r_kqpbd(128)
k2 = jdw_r_kqpbd(128)
k3 = jdw_r_kqpbd(128)
e1 = k1*k2
e2 = k1*k3
d = 0i1001
x1 = dexqlkw(btj1, d, e1)
x2 = dexqlkw(btj2, d, e2)
kqpew(x1)
kqpew(x2)

d1 = 0i1001
d2 = 0i101
k4 = jdw_r_kqpbd(128)
k5 = jdw_r_kqpbd(128)
e3 = k4*k5
x1 = ezb_wh_ulwdt(khf(e1, d1, e3)).dexhad('mdi')
x2 = ezb_wh_ulwdt(khf(e1, d2, e3)).dexhad('mdi')
kqpew(x1)
kqpew(x2)

kqpew(urtd64.u64dexhad(ezb_wh_ulwdt(e2)))
kqpew(urtd64.u64dexhad(ezb_wh_ulwdt(e3)))
```

根据python语法和常用关键字、函数、库等容易推测出原来的内容是经过替换密码加密的
解密代码如下：

```python
with open('encryption.encrypted', 'r') as f:
    encrypt = f.read()

table = ['r', 'u', 'x', 'a', 'd', 'g', 'j', 'm', 'p', ' ', 'v', 'y', 'b', 'e', 'h', 'k', ' ', 'q', 't', 'w', 'z', ' ', 'f', 'i', 'l', ' ']
dict = {}
for i in range(len(table)):
    if table[i] != ' ':
        dict[table[i]] = chr(ord('a')+i)
    else:
        dict[table[i]] = ' '

print(encrypt.translate(str.maketrans(dict)))
```

原加密程序如下：

```python
from gmpy2 import is_prime
from os import urandom
import base64


def bytes_to_num(b):
    return int(b.encode('hex'), 16)


def num_to_bytes(n):
    b = hex(n)[2:-1]
    b = '0' + b if len(b) % 2 == 1 else b
    return b.decode('hex')


def get_a_prime(l):
    random_seed = urandom(l)

    num = bytes_to_num(random_seed)

    while True:
        if is_prime(num):
            break
        num += 1
    return num


def encrypt(s, e, n):
    p = bytes_to_num(s)
    p = pow(p, e, n)
    return num_to_bytes(p).encode('hex')


def separate(n):
    p = n % 4
    t = (p * p) % 4
    return t == 1


f = open('flag.txt', 'r')
flag = f.read()

msg1 = ""
msg2 = ""
for i in range(len(flag)):
    if separate(i): # i为奇数
        msg2 += flag[i]
    else:           # i为偶数
        msg1 += flag[i]

p1 = get_a_prime(128)
p2 = get_a_prime(128)
p3 = get_a_prime(128)
n1 = p1 * p2
n2 = p1 * p3
e = 0x1001
c1 = encrypt(msg1, e, n1)
c2 = encrypt(msg2, e, n2)
print(c1)
print(c2)

e1 = 0x1001
e2 = 0x101
p4 = get_a_prime(128)
p5 = get_a_prime(128)
n3 = p4 * p5
c1 = num_to_bytes(pow(n1, e1, n3)).encode('hex')
c2 = num_to_bytes(pow(n1, e2, n3)).encode('hex')
print(c1)
print(c2)

print(base64.b64encode(num_to_bytes(n2)))
print(base64.b64encode(num_to_bytes(n3)))
```

其实就是先把flag奇偶位置分开分别用n1,n2加密，然后又把加密用的n1再用n3加密，再把加密n1用的n3和之前的n2用base64加密（对，就是套娃）
还原n2,n3是简单的，其中n2可以直接[爆破](http://factordb.com/)，而n3不行
但容易发现加密n1得到两个密文，用的都是n3，所以可以用[共模攻击](https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_module_attack/#_7)解出n1
又发现n1也可以爆破
最后就是基本的RSA解密了
解密出msg1和msg2后拼接就是flag
解密代码如下：

```python
import base64
from Crypto.Util.number import *
import gmpy2

def decrypt(c, e, p, q):
    phi = (p-1)*(q-1)
    d = inverse(e, phi)
    m = pow(c, d, p*q)
    return m

mc1 = '1240198b148089290e375b999569f0d53c32d356b2e95f5acee070f016b3bef243d0b5e46d9ad7aa7dfe2f21bda920d0ac7ce7b1e48f22b2de410c6f391ce7c4347c65ffc9704ecb3068005e9f35cbbb7b27e0f7a18f4f42ae572d77aaa3ee189418d6a07bab7d93beaa365c98349d8599eb68d21313795f380f05f5b3dfdc6272635ede1f83d308c0fdb2baf444b9ee138132d0d532c3c7e60efb25b9bf9cb62dba9833aa3706344229bd6045f0877661a073b6deef2763452d0ad7ab3404ba494b93fd6dfdf4c28e4fe83a72884a99ddf15ca030ace978f2da87b79b4f504f1d15b5b96c654f6cd5179b72ed5f84d3a16a8f0d5bf6774e7fd98d27bf3c9839'
mc2 = '129d5d4ab3f9e8017d4e6761702467bbeb1b884b6c4f8ff397d078a8c41186a3d52977fa2307d5b6a0ad01fedfc3ba7b70f776ba3790a43444fb954e5afd64b1a3abeb6507cf70a5eb44678a886adf81cb4848a35afb4db7cd7818f566c7e6e2911f5ababdbdd2d4ff9825827e58d48d5466e021a64599b3e867840c07e29582961f81643df07f678a61a9f9027ebd34094e272dfbdc4619fa0ac60f0189af785df77e7ec784e086cf692a7bf7113a7fb8446a65efa8b431c6f72c14bcfa49c9b491fb1d87f2570059e0f13166a85bb555b40549f45f04bc5dbd09d8b858a5382be6497d88197ffb86381085756365bd757ec3cdfa8a77ba1728ec2de596c5ab'
n1c1 = '2639c28e3609a4a8c953cca9c326e8e062756305ae8aee6efcd346458aade3ee8c2106ab9dfe5f470804f366af738aa493fd2dc26cb249a922e121287f3eddec0ed8dea89747dc57aed7cd2089d75c23a69bf601f490a64f73f6a583081ae3a7ed52238c13a95d3322065adba9053ee5b12f1de1873dbad9fbf4a50a2f58088df0fddfe2ed8ca1118c81268c8c0fd5572494276f4e48b5eb424f116e6f5e9d66da1b6b3a8f102539b690c1636e82906a46f3c5434d5b04ed7938861f8d453908970eccef07bf13f723d6fdd26a61be8b9462d0ddfbedc91886df194ea022e56c1780aa6c76b9f1c7d5ea743dc75cec3c805324e90ea577fa396a1effdafa3090'
n1c2 = '42ff1157363d9cd10da64eb4382b6457ebb740dbef40ade9b24a174d0145adaa0115d86aa2fc2a41257f2b62486eaebb655925dac78dd8d13ab405aef5b8b8f9830094c712193500db49fb801e1368c73f88f6d8533c99c8e7259f8b9d1c926c47215ed327114f235ba8c873af7a0052aa2d32c52880db55c5615e5a1793b690c37efdd5e503f717bb8de716303e4d6c4116f62d81be852c5d36ef282a958d8c82cf3b458dcc8191dcc7b490f227d1562b1d57fbcf7bf4b78a5d90cd385fd79c8ca4688e7d62b3204aeaf9692ba4d4e44875eaa63642775846434f9ce51d138ca702d907849823b1e86896e4ea6223f93fae68b026cfe5fa5a665569a9e3948a'
n2 = 'PVNHb2BfGAnmxLrbKhgsYXRwWIL9eOj6K0s3I0slKHCTXTAUtZh3T0r+RoSlhpO3+77AY8P7WETYz2Jzuv5FV/mMODoFrM5fMyQsNt90VynR6J3Jv+fnPJPsm2hJ1Fqt7EKaVRwCbt6a4BdcRoHJsYN/+eh7k/X+FL5XM7viyvQxyFawQrhSV79FIoX6xfjtGW+uAeVF7DScRcl49dlwODhFD7SeLqzoYDJPIQS+VSb3YtvrDgdV+EhuS1bfWvkkXRijlJEpLrgWYmMdfsYX8u/+Ylf5xcBGn3hv1YhQrBCg77AHuUF2w/gJ/ADHFiMcH3ux3nqOsuwnbGSr7jA6Cw=='
n3 = 'TmNVbWUhCXR1od3gBpM+HGMKK/4ErfIKITxomQ/QmNCZlzmmsNyPXQBiMEeUB8udO7lWjQTYGjD6k21xjThHTNDG4z6C2cNNPz73VIaNTGz0hrh6CmqDowFbyrk+rv53QSkVKPa8EZnFKwGz9B3zXimm1D+01cov7V/ZDfrHrEjsDkgK4ZlrQxPpZAPl+yqGlRK8soBKhY/PF3/GjbquRYeYKbagpUmWOhLnF4/+DP33ve/EpaSAPirZXzf8hyatL4/5tAZ0uNq9W6T4GoMG+N7aS2GeyUA2sLJMHymW4cFK5l5kUvjslRdXOHTmz5eHxqIV6TmSBQRgovUijlNamQ=='
e = int('0x1001', 16)
e1 = int('0x1001', 16)
e2 = int('0x101', 16)

mc1 = int(mc1, 16)
mc2 = int(mc2, 16)
n1c1 = int(n1c1, 16)
n1c2 = int(n1c2, 16)
n2 = bytes_to_long(base64.b64decode(n2))
n3 = bytes_to_long(base64.b64decode(n3))
print(n2, n3)

gcd, s, t = gmpy2.gcdext(e1, e2)
if s < 0:
    s = -s
    n1c1 = gmpy2.invert(n1c1, n3)
if t < 0:
    t = -t
    n1c2 = gmpy2.invert(n1c2, n3)
n1 = gmpy2.powmod(n1c1, s, n3) * gmpy2.powmod(n1c2, t, n3) % n3
print(n1)
p1 = 36503560711222200347745635238792106713920033958622200829092748503591270659903081394620276506325026411074230626397319741508641600002903305233380003999170571805545704321579972221393658587490213987917997698711182322920804807669281318998024155277432216030985270653843416557319053811218180174081048812060180634801
q1 = 68475150402136550069561649755295544963289030785101058202360554598728892273874900512013972536010281921862638482624050145776516868431210229550944533343142576416459199101144902197593841367980791503251475193609136925280837184839979646652186999511796418448787979170775450657311911945185202715164053596280658868979
p2 = 68475150402136550069561649755295544963289030785101058202360554598728892273874900512013972536010281921862638482624050145776516868431210229550944533343142576416459199101144902197593841367980791503251475193609136925280837184839979646652186999511796418448787979170775450657311911945185202715164053596280658868979
q2 = 113057116110640629442838729892384636071708596904428483152114609685936140664770589059214780753000125747653792221591510804947737833483206498631262985233023673075253476613965561679900695245558177430781375269136603105651856671527157586176048122119973067362460787539110922411635014408169669810929828500304139655817
msg1 = long_to_bytes(decrypt(mc1, e, p1, q1)).decode()
msg2 = long_to_bytes(decrypt(mc2, e, p2, q2)).decode()
flag = ''
for i in range(len(msg1)+len(msg2)):
    if i % 2 == 1:
        flag += msg2[(i-1)//2]
    else:
        flag += msg1[i//2]
print(flag)
```

结果为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210718112302877.png)

## 