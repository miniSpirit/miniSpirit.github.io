# week 4

# 2021-4-19

## signin

一看题目，签到题
附件内容：
welcome to crypto world！！
密文：424a447b57653163306d655f74345f424a444354467d
密文十六进制转码就行
代码如下：

```python
from Crypto.Util.number import *
s = '424a447b57653163306d655f74345f424a444354467d'
print(long_to_bytes(int(s, 16)))
```

## crypto-rsa0

拿到一个压缩包附件
解压的时候发现：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210419220625214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
嗯？不对劲
再把里面的压缩包解压
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210419220717290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
嗯？
给了一个提示：怎么办呢，出题人也太坏了，竟然把压缩包给伪加密了！
额。。。
什么是伪加密？
参考博客：[https://www.cnblogs.com/0yst3r-2046/p/11890498.html](https://www.cnblogs.com/0yst3r-2046/p/11890498.html)

阿巴阿巴阿巴
绿色框住的 50 4B 是压缩源文件目录区 ，它对应的绿色框柱的 09 00 影响加密属性，当数字为奇数是为加密，为偶数时不加密。
阿巴阿巴阿巴

好家伙，只要把 50 4B 后面的 09 00 改成偶数就行

然后就缺工具了
网上下 winhex 各种出问题
经过大佬指点，搞了 010 editor 的破解版（欸嘿嘿~）
然后搜索 50 4B 把后面的 09 00 修改即可
一个小插曲：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210419221504127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
解压之后得到 RSA 加密代码：

```python
from Cryptodome.Util.number import *
import random

FLAG=#hidden, please solve it
flag=int.from_bytes(FLAG,byteorder = 'big')


p=getPrime(512)
q=getPrime(512)

print(p)
print(q)
N=p*q
e=65537
enc = pow(flag,e,N)
print (enc)
```

啊这，p,q 都告诉了吗
直接解密就行
解密代码如下：

```python
from Crypto.Util.number import *

p = 9018588066434206377240277162476739271386240173088676526295315163990968347022922841299128274551482926490908399237153883494964743436193853978459947060210411
q = 7547005673877738257835729760037765213340036696350766324229143613179932145122130685778504062410137043635958208805698698169847293520149572605026492751740223
c = 50996206925961019415256003394743594106061473865032792073035954925875056079762626648452348856255575840166640519334862690063949316515750256545937498213476286637455803452890781264446030732369871044870359838568618176586206041055000297981733272816089806014400846392307742065559331874972274844992047849472203390350
e = 65537
n = p*q

phi = (p-1) * (q-1)
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
```

结果为：actf{n0w_y0u_see_RSA}

# 2021-4-20

## 一张谍报

题目给了一份报纸
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420225220955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
完全摸不着头脑
只能找 [wp](https://blkstone.github.io/2017/12/17/dbappsec-ctf/)
flag：南天菩萨放鹰捉猴头

## SameMod

共模攻击
不再赘述
详见 CTFwiki [共模攻击](https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_module_attack/)
题目给的数据都和 CTFwiki 的一模一样（啊这）
解密代码如下：

```python
import gmpy2

n = 6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249
e1 = 773
e2 = 839
message1=3453520592723443935451151545245025864232388871721682326408915024349804062041976702364728660682912396903968193981131553111537349
message2=5672818026816293344070119332536629619457163570036305296869053532293105379690793386019065754465292867769521736414170803238309535
# s & t
gcd, s, t = gmpy2.gcdext(e1, e2)
if s < 0:
    s = -s
    message1 = gmpy2.invert(message1, n)
if t < 0:
    t = -t
    message2 = gmpy2.invert(message2, n)
plain = gmpy2.powmod(message1, s, n) * gmpy2.powmod(message2, t, n) % n
i = 0
flag = ""
plain = str(plain)
while i < len(plain):
    if plain[i] == '1':
        flag += chr(int(plain[i:i + 3]))
        i += 3
    else:
        flag += chr(int(plain[i:i + 2]))
        i += 2
print(flag)
```

结果为：flag{whenwethinkitispossible}

## BabyRSA

加密代码如下：

```python
import hashlib
import sympy
from Crypto.Util.number import *

flag = 'GWHT{******}'
secret = '******'

assert(len(flag) == 38)

half = len(flag) / 2

flag1 = flag[:half]
flag2 = flag[half:]

secret_num = getPrime(1024) * bytes_to_long(secret)

p = sympy.nextprime(secret_num)
q = sympy.nextprime(p)

N = p * q

e = 0x10001

F1 = bytes_to_long(flag1)
F2 = bytes_to_long(flag2)

c1 = F1 + F2
c2 = pow(F1, 3) + pow(F2, 3)
assert(c2 < N)

m1 = pow(c1, e, N)
m2 = pow(c2, e, N)

output = open('secret', 'w')
output.write('N=' + str(N) + '\n')
output.write('m1=' + str(m1) + '\n')
output.write('m2=' + str(m2) + '\n')
output.close()
```

看来是把 flag 分成两段加密了
输出数据如下：

```python
N=636585149594574746909030160182690866222909256464847291783000651837227921337237899651287943597773270944384034858925295744880727101606841413640006527614873110651410155893776548737823152943797884729130149758279127430044739254000426610922834573094957082589539445610828279428814524313491262061930512829074466232633130599104490893572093943832740301809630847541592548921200288222432789208650949937638303429456468889100192613859073752923812454212239908948930178355331390933536771065791817643978763045030833712326162883810638120029378337092938662174119747687899484603628344079493556601422498405360731958162719296160584042671057160241284852522913676264596201906163
m1=90009974341452243216986938028371257528604943208941176518717463554774967878152694586469377765296113165659498726012712288670458884373971419842750929287658640266219686646956929872115782173093979742958745121671928568709468526098715927189829600497283118051641107305128852697032053368115181216069626606165503465125725204875578701237789292966211824002761481815276666236869005129138862782476859103086726091860497614883282949955023222414333243193268564781621699870412557822404381213804026685831221430728290755597819259339616650158674713248841654338515199405532003173732520457813901170264713085107077001478083341339002069870585378257051150217511755761491021553239
m2=487443985757405173426628188375657117604235507936967522993257972108872283698305238454465723214226871414276788912058186197039821242912736742824080627680971802511206914394672159240206910735850651999316100014691067295708138639363203596244693995562780286637116394738250774129759021080197323724805414668042318806010652814405078769738548913675466181551005527065309515364950610137206393257148357659666687091662749848560225453826362271704292692847596339533229088038820532086109421158575841077601268713175097874083536249006018948789413238783922845633494023608865256071962856581229890043896939025613600564283391329331452199062858930374565991634191495137939574539546
```

老规矩，先试试能不能爆破 N ：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420233738222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
啊这
爆破出来了
根据 RSA 的常规套路解出 c1, c2
由于
$$
c_{1} = f_{1} + f_{2} \\
c_{2} = f_{1}^{3} + f_{2}^{3}
$$
c2 又可以进行因式分解
$$
c_{2} = f_{1}^{3} + f_{2}^{3} = (f_{1} + f_{2} )(f_{1}^{2} - f_{1} f_{2} + f_{2}^{2})
$$
将 $c_{1} = f_{1} + f_{2}$ 代入得
$$
\frac{c_{2}}{c_{1}} = f_{1}^{2} - f_{1} f_{2} + f_{2}^{2} = (f_{1} + f_{2} )^{2} - 3f_{1} f_{2}
$$
可以求出 $f_{1} f_{2}$ 记为 $c_{3}$
然后可以构造一元二次方程
$$
x^{2} - c_{1}x + c_{3} = 0
$$
解出结果即为 $f1,f2$
最后解密即可
代码如下：

```python
from Crypto.Util.number import *
from sympy import *

p = 797862863902421984951231350430312260517773269684958456342860983236184129602390919026048496119757187702076499551310794177917920137646835888862706126924088411570997141257159563952725882214181185531209186972351469946269508511312863779123205322378452194261217016552527754513215520329499967108196968833163329724620251096080377747699
q = 797862863902421984951231350430312260517773269684958456342860983236184129602390919026048496119757187702076499551310794177917920137646835888862706126924088411570997141257159563952725882214181185531209186972351469946269508511312863779123205322378452194261217016552527754513215520329499967108196968833163329724620251096080377748737
N = 636585149594574746909030160182690866222909256464847291783000651837227921337237899651287943597773270944384034858925295744880727101606841413640006527614873110651410155893776548737823152943797884729130149758279127430044739254000426610922834573094957082589539445610828279428814524313491262061930512829074466232633130599104490893572093943832740301809630847541592548921200288222432789208650949937638303429456468889100192613859073752923812454212239908948930178355331390933536771065791817643978763045030833712326162883810638120029378337092938662174119747687899484603628344079493556601422498405360731958162719296160584042671057160241284852522913676264596201906163
m1= 90009974341452243216986938028371257528604943208941176518717463554774967878152694586469377765296113165659498726012712288670458884373971419842750929287658640266219686646956929872115782173093979742958745121671928568709468526098715927189829600497283118051641107305128852697032053368115181216069626606165503465125725204875578701237789292966211824002761481815276666236869005129138862782476859103086726091860497614883282949955023222414333243193268564781621699870412557822404381213804026685831221430728290755597819259339616650158674713248841654338515199405532003173732520457813901170264713085107077001478083341339002069870585378257051150217511755761491021553239
m2 = 487443985757405173426628188375657117604235507936967522993257972108872283698305238454465723214226871414276788912058186197039821242912736742824080627680971802511206914394672159240206910735850651999316100014691067295708138639363203596244693995562780286637116394738250774129759021080197323724805414668042318806010652814405078769738548913675466181551005527065309515364950610137206393257148357659666687091662749848560225453826362271704292692847596339533229088038820532086109421158575841077601268713175097874083536249006018948789413238783922845633494023608865256071962856581229890043896939025613600564283391329331452199062858930374565991634191495137939574539546
e = int('0x10001', 16)
phi = (p-1)*(q-1)
d = inverse(e, phi)
c1 = pow(m1, d, N) # f1 + f2
c2 = pow(m2, d, N) # f1^3 + f2^3
c3 = (c1**2 - c2//c1) // 3 # f1 * f2
x = symbols('x')
f1, f2 = solve(Eq(x**2 - c1*x + c3,0),x)
print(long_to_bytes(f2) + long_to_bytes(f1))
```

结果为：GWHT{f709e0e2cfe7e530ca8972959a1033b2}

# 2021-4-21

## yxx

题目给了一个密文、一个明文
密文一堆乱码
明文：lovelovelovelovelovelovelovelove
联想到之前做过的一道题：[异性相吸](https://blog.csdn.net/weixin_52446095/article/details/115464659?spm=1001.2014.3001.5501)
大概又是要做异或操作
代码如下：

```python
key = 'lovelovelovelovelovelovelovelove'
with open(r'密文.txt', 'r') as f:
    m = f.read()

c = ''
for i in range(len(m)):
    c += chr(ord(m[i]) ^ ord(key[i]))
print(c)
```

结果为：flag:nctf{xor_xor_xor_biueiubiu}
但是怎么都不对
找到大佬的 [wp](https://www.codeleading.com/article/51553078742/)
结果为：flag:nctf{xor_xor_xor_biubiubiu}
啊这
感觉也没什么不对的啊

## babyrsa

一道非常基础的 RSA 题
n 不长，可以爆破
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421214054795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
代码如下：

```python
from Crypto.Util.number import *

c = 28767758880940662779934612526152562406674613203406706867456395986985664083182
n = 73069886771625642807435783661014062604264768481735145873508846925735521695159
e = 65537
p = 189239861511125143212536989589123569301
q = 386123125371923651191219869811293586459

phi = (p-1)*(q-1)
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
```

结果为：wctf2020{just_@_piece_0f_cak3}

## RSA4

附件给了三对 N 和 c
猜测是广播攻击
但是，怎么没有 e
果断找 [wp](https://blog.csdn.net/weixin_44017838/article/details/105058745)（擦汗）
啊这
原来给的是五进制数吗
猜想 e=3 是什么操作？
不过每对 N 和 c 都相差一位，e 也不会达到哪去就是了。。。
至于 CRT 算法，懒得写了，直接用 sagemath 封装好的
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421220158328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
求出了 m
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421220221500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
得到结果

# 2021-4-22

## 浪里淘沙

题目描述：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210422202220495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
附件内容：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210422202243579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
一脸懵逼
答案见 [wp](https://blog.csdn.net/weixin_44017838/article/details/104888540)[doge]

## Vigenère

维吉尼亚密码
不管，直接[爆破](https://www.guballa.de/vigenere-solver)
答案：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210422202410305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)

## 这是什么觅🐎

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210422204405934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
扫了二维码，什么都没发现
附件没有后缀
用 010editor 打开
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210422204956382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
发现是 zip 文件
后缀名改为 .zip
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210422205124431.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70#pic_center)
内容是一张图片
右下角的数字和字母容易猜测代表
分别代表日历中的列和行
得到的日期，对应字母表中的字母
结果为 calendar

# 2021-4-23

## babyRSA

题目只给了 e, d, c
根据加密代码：

```python
from Crypto.Util.number import *
from flag import flag

def nextPrime(n):
    n += 2 if n & 1 else 1
    while not isPrime(n):
        n += 2
    return n

p = getPrime(1024)
q = nextPrime(p)
n = p * q
e = 0x10001
d = inverse(e, (p-1) * (q-1))
c = pow(bytes_to_long(flag.encode()), e, n)

```

我们得知 p 是一个 1024 位的素数，而 q 是 p 的下一个素数
所以，根据
$$
\varphi = (p-1)*(q-1)
$$
可以大致推断 $\varphi$ 介于 $(2^{1023})^2$ 与 $(2^{1024})^2$ 之间
根据
$$
e * d \equiv 1 \space (mod \space \varphi)
$$
推出 $\exists\space k \in\mathbb{Z}, \space s.t.$
$$
e * d = 1 +  k * \varphi
$$
再计算 $e * d - 1$ ，发现是一个 2066 位的数
可以推出 $k$ 是介于 $2^{15}$ 与 $2^{16}$ 之间的数
据此可以爆破出 $k$，然后得出 p, q ，完成解密
代码如下：

```python
from Crypto.Util.number import *
from gmpy2 import *
from sympy import *

d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913
c = 5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804
e = int('0x10001', 16)
kphi = e*d-1

print(len(bin(kphi)))
p = 0
q = 0
for k in range(pow(2, 15), pow(2, 16)):
    if kphi % k == 0:
        p = prevprime(iroot(kphi//k, 2)[0])
        q = nextprime(p)
        if (p-1)*(q-1)*k == kphi:
            break

n = p*q
m = pow(c, d, n)
print(long_to_bytes(m))
```

参考博客：[https://blog.csdn.net/weixin_45441024/article/details/110351394](https://blog.csdn.net/weixin_45441024/article/details/110351394)

## easyrsa

加密代码如下：

```python
from Crypto.Util.number import getPrime,bytes_to_long
from sympy import Derivative
from fractions import Fraction
from secret import flag

p=getPrime(1024)
q=getPrime(1024)
e=65537
n=p*q
z=Fraction(1,Derivative(arctan(p),p))-Fraction(1,Derivative(arth(q),q))
m=bytes_to_long(flag)
c=pow(m,e,n)
print(c,z,n)
```

特别的地方就是引入了一个 z
不管，先尝试[爆破](http://factordb.com/) n：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210423201754971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
啊这
让我爆破出来了
然后就是常规的 RSA 操作
代码如下：

```python
from Crypto.Util.number import *

p = 105909195259921349656664570904199242969110902804477734660927330311460997899731622163728968380757294196277263615386525795293086103142131020215128282050307177125962302515483190468569376643751587606016315185736245896434947691528567696271911398179288329609207435393579332931583829355558784305002360873458907029141
q = 144564833334456076455156647979862690498796694770100520405218930055633597500009574663803955456004439398699669751249623406199542605271188909145969364476344963078599240058180033000440459281558347909876143313940657252737586803051935392596519226965519859474501391969755712097119163926672753588797180811711004203301
n = 15310745161336895413406690009324766200789179248896951942047235448901612351128459309145825547569298479821101249094161867207686537607047447968708758990950136380924747359052570549594098569970632854351825950729752563502284849263730127586382522703959893392329333760927637353052250274195821469023401443841395096410231843592101426591882573405934188675124326997277775238287928403743324297705151732524641213516306585297722190780088180705070359469719869343939106529204798285957516860774384001892777525916167743272419958572055332232056095979448155082465977781482598371994798871917514767508394730447974770329967681767625495394441
c = 7922547866857761459807491502654216283012776177789511549350672958101810281348402284098310147796549430689253803510994877420135537268549410652654479620858691324110367182025648788407041599943091386227543182157746202947099572389676084392706406084307657000104665696654409155006313203957292885743791715198781974205578654792123191584957665293208390453748369182333152809882312453359706147808198922916762773721726681588977103877454119043744889164529383188077499194932909643918696646876907327364751380953182517883134591810800848971719184808713694342985458103006676013451912221080252735948993692674899399826084848622145815461035
e = 65537

phi = (p-1)*(q-1)
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
```

回过来我们揣测出题人引入 $z$ 的意图
首先
$$
z = \frac{1}{\frac{d(arctan(p))}{dp}} + \frac{1}{\frac{d(arth(q))}{dq}}
$$
又因为反正切函数和反双曲正切函数的导数分别为：
$$
\frac{d(arctan(x))}{dx} = \frac{1}{1 + x^{2}},\\
\frac{d(arth(x))}{dx} = \frac{1}{1 - x^{2}}
$$
所以
$$
z = \frac{1}{\frac{1}{1 + p^{2}}} + \frac{1}{\frac{1}{1 - q^{2}}}=p^{2} + q^{2}
$$
又因为 $n = p*q$，我们可以求出 $p + q$
再根据
$$
\varphi = (p-1)*(q-1) = p*q - p - q + 1 = n - (p+q) + 1
$$
可以求出 $\varphi$
然后进行解密
代码如下：

```python
from gmpy2 import *
from Crypto.Util.number import *

n = 15310745161336895413406690009324766200789179248896951942047235448901612351128459309145825547569298479821101249094161867207686537607047447968708758990950136380924747359052570549594098569970632854351825950729752563502284849263730127586382522703959893392329333760927637353052250274195821469023401443841395096410231843592101426591882573405934188675124326997277775238287928403743324297705151732524641213516306585297722190780088180705070359469719869343939106529204798285957516860774384001892777525916167743272419958572055332232056095979448155082465977781482598371994798871917514767508394730447974770329967681767625495394441
c = 7922547866857761459807491502654216283012776177789511549350672958101810281348402284098310147796549430689253803510994877420135537268549410652654479620858691324110367182025648788407041599943091386227543182157746202947099572389676084392706406084307657000104665696654409155006313203957292885743791715198781974205578654792123191584957665293208390453748369182333152809882312453359706147808198922916762773721726681588977103877454119043744889164529383188077499194932909643918696646876907327364751380953182517883134591810800848971719184808713694342985458103006676013451912221080252735948993692674899399826084848622145815461035
z = 32115748677623209667471622872185275070257924766015020072805267359839059393284316595882933372289732127274076434587519333300142473010344694803885168557548801202495933226215437763329280242113556524498457559562872900811602056944423967403777623306961880757613246328729616643032628964072931272085866928045973799374711846825157781056965164178505232524245809179235607571567174228822561697888645968559343608375331988097157145264357626738141646556353500994924115875748198318036296898604097000938272195903056733565880150540275369239637793975923329598716003350308259321436752579291000355560431542229699759955141152914708362494482
e = 65537

p_q = iroot(z + 2*n, 2)[0] # p+q
phi = n - p_q + 1
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
```

结果为：BJD{Advanced_mathematics_is_too_hard!!!}

# 2021-4-24

## 你能看出这是什么加密么

附件内容如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210424212602804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
这不一看就是 RSA 嘛
复制粘贴之后：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210424212711945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
嗯？
怎么后面还有乱码？
不管，先删了试试看能把也能解密
代码如下：

```python
from Crypto.Util.number import *

p = int('0x928fb6aa9d813b6c3270131818a7c54edb18e3806942b88670106c1821e0326364194a8c49392849432b37632f0abe3f3c52e909b939c91c50e41a7b8cd00c67d6743b4f', 16)
q = int('0xec301417ccdffa679a8dcc4027dd0d75baf9d441625ed8930472165717f4732884c33f25d4ee6a6c9ae6c44aedad039b0b72cf42cab7f80d32b74061', 16)
e = int('0x10001', 16)
c = int('0x70c9133e1647e95c3cb99bd998a9028b5bf492929725a9e8e6d2e277fa0f37205580b196e5f121a2e83bc80a8204c99f5036a07c8cf6f96c420369b4161d2654a7eccbdaf583204b645e137b3bd15c5ce865298416fd5831cba0d947113ed5be5426b708b89451934d11f9aed9085b48b729449e461ff0863552149b965e22b6', 16)

n = p*q
phi = (p-1)*(q-1)
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
```

结果为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210424212821672.png)
嗯？
一堆乱码
翻到最后发现：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210424212854763.png)
啊这
结果就是：afctf{R54_|5_\$0_\$imp13}

## crypto-rsa3

普通的 RSA
n 不长，可以直接[爆破](http://factordb.com/)
结果为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210424213134863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
然后解密即可
代码如下：

```python
from Crypto.Util.number import *

e = 65537
n = 177606504836499246970959030226871608885969321778211051080524634084516973331441644993898029573612290095853069264036530459253652875586267946877831055147546910227100566496658148381834683037366134553848011903251252726474047661274223137727688689535823533046778793131902143444408735610821167838717488859902242863683
c = 1457390378511382354771000540945361168984775052693073641682375071407490851289703070905749525830483035988737117653971428424612332020925926617395558868160380601912498299922825914229510166957910451841730028919883807634489834128830801407228447221775264711349928156290102782374379406719292116047581560530382210049
p = 13326909050357447643526585836833969378078147057723054701432842192988717649385731430095055622303549577233495793715580004801634268505725255565021519817179231
q = 13326909050357447643526585836833969378078147057723054701432842192988717649385731430095055622303549577233495793715580004801634268505725255565021519817179293

phi = (p-1)*(q-1)
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
```

结果为：actf{p_and_q_should_not_be_so_close_in_value}

# 2021-4-25

## 鸡藕椒盐味

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210425223305213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
什么玩意？
直接找 [wp](https://www.dazhuanlan.com/2019/12/17/5df7e64bc03b2/)（
原来“鸡藕椒盐味”是“奇偶校验位”的谐音
然后用汉明码还原最后md5
[代码](https://blog.csdn.net/weixin_44017838/article/details/104889490)

## crypto-classic0

拿到附件解压
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021042523210447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
嗯？
没解压完？
难道又是伪加密？
用 010editor 看了之后，也没有伪加密的特征啊
里面还有个压缩包要密码
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210425232245660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
给了个提示
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210425232321333.png)
还是摸不着头脑
只能找 [wp](https://blog.csdn.net/seven749/article/details/109606928)（
结果是个工具题
要用 ziperello 爆破
但是找了半天找不到都下载失败了（
然后在 [b站上](https://www.bilibili.com/video/BV1EK4y187WG?from=search&seid=579101326676298682)，找到了这么一个[链接](https://ww.lanzous.com/icug02f)
找到了一个代替的软件
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210425232722549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
爆破出密码
加密代码为：

```c
#include<stdio.h>

char flag[25] = ***

int main()
{
	int i;
	for(i=0;i<25;i++)
	{
		flag[i] -= 3;
		flag[i] ^= 0x7;
		printf("%c",flag[i]);
	}
	return 0; 
}
```

根据加密代码写解密代码即可
代码如下：

```c
#include<stdio.h>

char flag[25] = "Ygvdmq[lYate[elghqvakl}";

int main()
{
	int i;
	for(i=0;i<25;i++)
	{
        flag[i] ^= 0x7;
		flag[i] += 3;
		printf("%c",flag[i]);
	}
	return 0; 
}
```

结果为：actf{my_naive_encrytion}